name: Build-GeoSite-Dat

on:
  workflow_dispatch: # –¢–æ–ª—å–∫–æ —Ä—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # –ü–æ–ª–Ω–∞—è –∏—Å—Ç–æ—Ä–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'

      - name: Check for changes in geosite data
        id: check_changes
        run: |
          echo "Checking for changes in geosite data files..."
          
          # –°–æ–∑–¥–∞–µ–º –ø–∞–ø–∫—É –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
          mkdir -p geosite.dat/data
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ geosite.dat/data —Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ –∫–æ–º–º–∏—Ç–∞
          if git diff --name-only HEAD~1 -- geosite.dat/data/ 2>/dev/null | grep -q .; then
            echo "Changes detected in geosite data files"
            echo "has_changes=true" >> $GITHUB_OUTPUT
          else
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ geosite.dat
            if [ -f "geosite.dat" ]; then
              echo "No changes in geosite data files, geosite.dat already exists"
              echo "has_changes=false" >> $GITHUB_OUTPUT
            else
              echo "No geosite.dat found, will generate"
              echo "has_changes=true" >> $GITHUB_OUTPUT
            fi
          fi

      - name: Validate GeoSite Files
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          echo "Validating geosite data files..."
          cd geosite.dat/data
          
          ERROR_COUNT=0
          
          for file in *.txt; do
            if [ -f "$file" ]; then
              echo "Validating $file..."
              
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ñ–∞–π–ª –Ω–µ –ø—É—Å—Ç–æ–π
              if [ ! -s "$file" ]; then
                echo "‚ùå ERROR: $file is empty"
                ERROR_COUNT=$((ERROR_COUNT + 1))
                continue
              fi
              
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç (–¥–æ–ª–∂–µ–Ω –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å –≥–µ–æ–∫–æ–¥–∞)
              filename_no_ext="${file%.txt}"
              if ! grep -q "^${filename_no_ext}:" "$file"; then
                echo "‚ùå ERROR: $file should start with '${filename_no_ext}:'"
                ERROR_COUNT=$((ERROR_COUNT + 1))
              fi
              
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∑–∞–ø—Ä–µ—â—ë–Ω–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
              if grep -q "^*" "$file" || grep -q "^@" "$file" || grep -q "^regexp:" "$file"; then
                echo "‚ö†Ô∏è  WARNING: $file contains advanced patterns (regex/domain/attributes)"
                echo "   These patterns will be included but may require special handling in Xray"
              fi
              
              # –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–∞–∑–æ–≤—ã–π —Å–∏–Ω—Ç–∞–∫—Å–∏—Å
              LINE_NUM=0
              while IFS= read -r line; do
                LINE_NUM=$((LINE_NUM + 1))
                line=$(echo "$line" | sed 's/#.*//' | xargs) # –£–¥–∞–ª—è–µ–º –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏ –ø—Ä–æ–±–µ–ª—ã
                
                if [ -z "$line" ]; then
                  continue
                fi
                
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ñ–æ—Ä–º–∞—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç Xray:
                # 1. domain: (–∞—Ç—Ä–∏–±—É—Ç—ã)
                # 2. regexp: (—Ä–µ–≥—É–ª—è—Ä–Ω—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è)
                # 3. * (–¥–æ–º–µ–Ω—ã)
                # 4. @ (–≥—Ä—É–ø–ø—ã —Å—Å—ã–ª–æ–∫)
                # 5. –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ full: (–≤—Å–µ –ø–æ–¥–¥–æ–º–µ–Ω—ã)
                
                if [[ "$line" == *" "* ]] && [[ ! "$line" =~ ^[a-zA-Z]+:[a-zA-Z]+\| ]]; then
                  echo "‚ö†Ô∏è  WARNING: Line $LINE_NUM in $file contains spaces: '$line'"
                  echo "   Xray geosite format doesn't support spaces except in attributes"
                fi
              done < "$file"
              
              echo "‚úÖ $file validation completed"
            fi
          done
          
          if [ $ERROR_COUNT -gt 0 ]; then
            echo "‚ùå Validation failed with $ERROR_COUNT error(s)"
            exit 1
          fi
          
          echo "‚úÖ All geosite files validated successfully"

      - name: Create GeoSite Generator Script
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          echo "Creating geosite generator script..."
          
          cat << 'EOF' > generate_geosite.go
          package main
          
          import (
          	"bufio"
          	"encoding/binary"
          	"fmt"
          	"log"
          	"os"
          	"path/filepath"
          	"sort"
          	"strings"
          )
          
          type Site struct {
          	Type  string
          	Value string
          	Attrs []string
          }
          
          func writeVarint(v uint32) []byte {
          	var buf [binary.MaxVarintLen32]byte
          	n := binary.PutUvarint(buf[:], uint64(v))
          	return buf[:n]
          }
          
          func encodeField(num int, wireType int, data []byte) []byte {
          	tag := uint32((num << 3) | wireType)
          	res := writeVarint(tag)
          	if wireType == 2 {
          		res = append(res, writeVarint(uint32(len(data)))...)
          	}
          	res = append(res, data...)
          	return res
          }
          
          func encodeString(s string) []byte {
          	return encodeField(1, 2, []byte(s))
          }
          
          func parseLine(line string) (string, *Site) {
          	line = strings.TrimSpace(line)
          	if line == "" || strings.HasPrefix(line, "#") {
          		return "", nil
          	}
          	
          	// –†–∞–∑–¥–µ–ª—è–µ–º –Ω–∞ —á–∞—Å—Ç–∏
          	parts := strings.SplitN(line, " ", 2)
          	pattern := parts[0]
          	var attrs []string
          	if len(parts) > 1 {
          		attrStr := parts[1]
          		attrParts := strings.Split(attrStr, " ")
          		for _, attr := range attrParts {
          			attr = strings.TrimSpace(attr)
          			if attr != "" {
          				attrs = append(attrs, attr)
          			}
          		}
          	}
          	
          	// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –ø–∞—Ç—Ç–µ—Ä–Ω–∞
          	var patternType, patternValue string
          	
          	if strings.HasPrefix(pattern, "domain:") {
          		patternType = "domain"
          		patternValue = strings.TrimPrefix(pattern, "domain:")
          	} else if strings.HasPrefix(pattern, "regexp:") {
          		patternType = "regexp"
          		patternValue = strings.TrimPrefix(pattern, "regexp:")
          	} else if strings.HasPrefix(pattern, "full:") {
          		patternType = "full"
          		patternValue = strings.TrimPrefix(pattern, "full:")
          	} else if pattern == "@" {
          		patternType = "reference"
          		patternValue = "@"
          	} else if strings.HasPrefix(pattern, "@") {
          		patternType = "reference"
          		patternValue = strings.TrimPrefix(pattern, "@")
          	} else {
          		patternType = "domain"
          		patternValue = pattern
          	}
          	
          	return pattern, &Site{
          		Type:  patternType,
          		Value: patternValue,
          		Attrs: attrs,
          	}
          }
          
          func encodeSite(site *Site) []byte {
          	var data []byte
          	
          	// –¢–∏–ø –ø–∞—Ç—Ç–µ—Ä–Ω–∞
          	data = append(data, encodeField(1, 2, []byte(site.Type))...)
          	
          	// –ó–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω–∞
          	data = append(data, encodeField(2, 2, []byte(site.Value))...)
          	
          	// –ê—Ç—Ä–∏–±—É—Ç—ã
          	for _, attr := range site.Attrs {
          		data = append(data, encodeField(3, 2, []byte(attr))...)
          	}
          	
          	return data
          }
          
          func main() {
          	dataDir := "geosite.dat/data"
          	outputFile := "geosite.dat"
          	
          	// –ß–∏—Ç–∞–µ–º –≤—Å–µ —Ñ–∞–π–ª—ã –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
          	files, err := os.ReadDir(dataDir)
          	if err != nil {
          		log.Fatalf("Failed to read data directory: %v", err)
          	}
          	
          	var allEntries []byte
          	
          	for _, f := range files {
          		if f.IsDir() || !strings.HasSuffix(f.Name(), ".txt") {
          			continue
          		}
          		
          		geoCode := strings.TrimSuffix(f.Name(), ".txt")
          		fmt.Printf("Processing: %s\n", geoCode)
          		
          		filePath := filepath.Join(dataDir, f.Name())
          		file, err := os.Open(filePath)
          		if err != nil {
          			log.Printf("Warning: Failed to open %s: %v", filePath, err)
          			continue
          		}
          		
          		var sites []*Site
          		scanner := bufio.NewScanner(file)
          		
          		for scanner.Scan() {
          			line := scanner.Text()
          			pattern, site := parseLine(line)
          			if site != nil && pattern != "" {
          				sites = append(sites, site)
          			}
          		}
          		
          		file.Close()
          		
          		if err := scanner.Err(); err != nil {
          			log.Printf("Warning: Error reading %s: %v", filePath, err)
          		}
          		
          		// –°–æ—Ä—Ç–∏—Ä—É–µ–º —Å–∞–π—Ç—ã –¥–ª—è –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –≤—ã–≤–æ–¥–∞
          		sort.Slice(sites, func(i, j int) bool {
          			if sites[i].Type != sites[j].Type {
          				return sites[i].Type < sites[j].Type
          			}
          			return sites[i].Value < sites[j].Value
          		})
          		
          		// –ö–æ–¥–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —ç—Ç–æ–π –≥–µ–æ–∑–æ–Ω—ã
          		var geoData []byte
          		
          		// –ì–µ–æ–∫–æ–¥
          		geoData = append(geoData, encodeField(1, 2, []byte(geoCode))...)
          		
          		// –°–∞–π—Ç—ã
          		for _, site := range sites {
          			siteData := encodeSite(site)
          			geoData = append(geoData, encodeField(2, 2, siteData)...)
          		}
          		
          		// –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ–±—â–∏–π —Å–ø–∏—Å–æ–∫
          		allEntries = append(allEntries, encodeField(1, 2, geoData)...)
          		
          		fmt.Printf("  Added %d sites for %s\n", len(sites), geoCode)
          	}
          	
          	// –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ —Ñ–∞–π–ª
          	if err := os.WriteFile(outputFile, allEntries, 0644); err != nil {
          		log.Fatalf("Failed to write output file: %v", err)
          	}
          	
          	fmt.Printf("\n‚úÖ Successfully generated %s\n", outputFile)
          	fmt.Printf("üìä Total size: %d bytes\n", len(allEntries))
          }
          EOF

      - name: Generate GeoSite Binary
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          echo "Generating geosite.dat binary file..."
          go run generate_geosite.go
          
          # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ–∑–¥–∞–Ω–Ω—ã–π —Ñ–∞–π–ª
          if [ ! -f "geosite.dat" ] || [ ! -s "geosite.dat" ]; then
            echo "‚ùå ERROR: geosite.dat was not generated or is empty!"
            exit 1
          fi
          
          echo "‚úÖ geosite.dat generated successfully"
          echo "üìè File size: $(wc -c < geosite.dat) bytes"

      - name: Generate Checksum
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          sha256sum geosite.dat > geosite.dat.sha256sum
          echo "SHA256 Checksum:"
          cat geosite.dat.sha256sum

      - name: Set Release Date
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          RELEASE_DATE=$(date +'%Y-%m-%d %H:%M')
          echo "RELEASE_DATE=${RELEASE_DATE}" >> $GITHUB_ENV
          
          # –ü–æ–¥—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
          cd geosite.dat/data
          TOTAL_FILES=$(ls *.txt 2>/dev/null | wc -l)
          TOTAL_LINES=0
          for file in *.txt; do
            if [ -f "$file" ]; then
              LINES=$(grep -v '^#' "$file" | grep -v '^$' | wc -l)
              TOTAL_LINES=$((TOTAL_LINES + LINES))
            fi
          done
          
          echo "STATS_FILES=${TOTAL_FILES}" >> $GITHUB_ENV
          echo "STATS_LINES=${TOTAL_LINES}" >> $GITHUB_ENV

      - name: Skip Generation (No Changes)
        if: steps.check_changes.outputs.has_changes == 'false'
        run: |
          echo "‚è≠Ô∏è  No changes detected in geosite data files"
          echo "Skipping binary generation"
          echo "Using existing geosite.dat"

      - name: Delete Old Release Tag
        run: |
          # –£–¥–∞–ª—è–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–π –∏ —É–¥–∞–ª–µ–Ω–Ω—ã–π —Ç–µ–≥ latest
          git tag -d latest 2>/dev/null || true
          git push origin :refs/tags/latest 2>/dev/null || true

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: latest
          name: "GeoSite Build: $(date +'%Y-%m-%d %H:%M')"
          body: |
            ## GeoSite Data Build
            
            **–î–∞—Ç–∞ —Å–±–æ—Ä–∫–∏:** $(date +'%Y-%m-%d %H:%M')
            **–§–∞–π–ª–æ–≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏:** ${{ env.STATS_FILES || 'N/A' }}
            **–í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π:** ${{ env.STATS_LINES || 'N/A' }}
            
            ### –§–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–æ–≤:
            –§–∞–π–ª—ã –≤ `geosite.dat/data/` –¥–æ–ª–∂–Ω—ã —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å —Ñ–æ—Ä–º–∞—Ç—É Xray GeoSite:
            
            ```
            geocode:
            domain:example.com @attr1 @attr2
            full:example.org
            regexp:^https?://.*\.example\.com/
            @another-list
            ```
            
            ### –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —Å Xray:
            ```json
            {
              "routing": {
                "rules": [
                  {
                    "type": "field",
                    "outboundTag": "direct",
                    "domain": ["geosite:category-name"]
                  }
                ]
              }
            }
            ```
            
            ### –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏:
            ```
            sha256sum: $(sha256sum geosite.dat | cut -d' ' -f1)
            ```
          draft: false
          prerelease: false
          make_latest: true
          files: |
            geosite.dat
            geosite.dat.sha256sum
          generate_release_notes: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
